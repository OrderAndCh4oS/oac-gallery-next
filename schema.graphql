# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
) on QUERY

"columns and relationships of \"events\""
type events {
    amount: bigint
    artist_address: String
    "An object relationship"
    artist_profile: tzprofiles
    ask_id: bigint
    auction_id: bigint
    bid: bigint
    bid_id: bigint
    bidder_address: String
    "An object relationship"
    bidder_profile: tzprofiles
    burn_on_end: Boolean
    buyer_address: String
    "An object relationship"
    buyer_profile: tzprofiles
    collection_id: bigint
    creator_name: String
    currency: String
    current_price: bigint
    editions: bigint
    eightscribo_rowone: String
    eightscribo_rowthree: String
    eightscribo_rowtwo: String
    eightscribo_title: String
    end_price: bigint
    end_time: timestamptz
    extension_time: bigint
    fa2_address: String
    from_address: String
    "An object relationship"
    from_profile: tzprofiles
    highest_bidder_address: String
    "An object relationship"
    highest_bidder_profile: tzprofiles
    holder_address: String
    "An object relationship"
    holder_profile: tzprofiles
    id: String!
    implements: String
    is_mint: Boolean
    is_verified_artist: Boolean
    issuer_id: bigint
    iteration: bigint
    kalamint_edition: bigint
    kalamint_editions: bigint
    ledger_type: String
    level: bigint!
    metadata(
        "JSON select path"
        path: String
    ): jsonb
    metadata_uri: String
    offer_id: bigint
    ophash: String
    opid: bigint!
    owner_address: String
    "An object relationship"
    owner_profile: tzprofiles
    price: bigint
    price_increment: bigint
    reserve: bigint
    rgb: String
    royalties: bigint
    royalty_shares(
        "JSON select path"
        path: String
    ): jsonb
    seller_address: String
    "An object relationship"
    seller_profile: tzprofiles
    start_price: bigint
    start_time: timestamptz
    swap_id: bigint
    timestamp: timestamptz!
    to_address: String
    "An object relationship"
    to_profile: tzprofiles
    "An object relationship"
    token: tokens
    token_description: String
    token_id: String
    token_name: String
    total_price: bigint
    type: String
}

"aggregated selection of \"events\""
type events_aggregate {
    aggregate: events_aggregate_fields
    nodes: [events!]!
}

"aggregate fields of \"events\""
type events_aggregate_fields {
    avg: events_avg_fields
    count(columns: [events_select_column!], distinct: Boolean): Int!
    max: events_max_fields
    min: events_min_fields
    stddev: events_stddev_fields
    stddev_pop: events_stddev_pop_fields
    stddev_samp: events_stddev_samp_fields
    sum: events_sum_fields
    var_pop: events_var_pop_fields
    var_samp: events_var_samp_fields
    variance: events_variance_fields
}

"aggregate avg on columns"
type events_avg_fields {
    amount: Float
    ask_id: Float
    auction_id: Float
    bid: Float
    bid_id: Float
    collection_id: Float
    current_price: Float
    editions: Float
    end_price: Float
    extension_time: Float
    issuer_id: Float
    iteration: Float
    kalamint_edition: Float
    kalamint_editions: Float
    level: Float
    offer_id: Float
    opid: Float
    price: Float
    price_increment: Float
    reserve: Float
    royalties: Float
    start_price: Float
    swap_id: Float
    total_price: Float
}

"aggregate max on columns"
type events_max_fields {
    amount: bigint
    artist_address: String
    ask_id: bigint
    auction_id: bigint
    bid: bigint
    bid_id: bigint
    bidder_address: String
    buyer_address: String
    collection_id: bigint
    creator_name: String
    currency: String
    current_price: bigint
    editions: bigint
    eightscribo_rowone: String
    eightscribo_rowthree: String
    eightscribo_rowtwo: String
    eightscribo_title: String
    end_price: bigint
    end_time: timestamptz
    extension_time: bigint
    fa2_address: String
    from_address: String
    highest_bidder_address: String
    holder_address: String
    id: String
    implements: String
    issuer_id: bigint
    iteration: bigint
    kalamint_edition: bigint
    kalamint_editions: bigint
    ledger_type: String
    level: bigint
    metadata_uri: String
    offer_id: bigint
    ophash: String
    opid: bigint
    owner_address: String
    price: bigint
    price_increment: bigint
    reserve: bigint
    rgb: String
    royalties: bigint
    seller_address: String
    start_price: bigint
    start_time: timestamptz
    swap_id: bigint
    timestamp: timestamptz
    to_address: String
    token_description: String
    token_id: String
    token_name: String
    total_price: bigint
    type: String
}

"aggregate min on columns"
type events_min_fields {
    amount: bigint
    artist_address: String
    ask_id: bigint
    auction_id: bigint
    bid: bigint
    bid_id: bigint
    bidder_address: String
    buyer_address: String
    collection_id: bigint
    creator_name: String
    currency: String
    current_price: bigint
    editions: bigint
    eightscribo_rowone: String
    eightscribo_rowthree: String
    eightscribo_rowtwo: String
    eightscribo_title: String
    end_price: bigint
    end_time: timestamptz
    extension_time: bigint
    fa2_address: String
    from_address: String
    highest_bidder_address: String
    holder_address: String
    id: String
    implements: String
    issuer_id: bigint
    iteration: bigint
    kalamint_edition: bigint
    kalamint_editions: bigint
    ledger_type: String
    level: bigint
    metadata_uri: String
    offer_id: bigint
    ophash: String
    opid: bigint
    owner_address: String
    price: bigint
    price_increment: bigint
    reserve: bigint
    rgb: String
    royalties: bigint
    seller_address: String
    start_price: bigint
    start_time: timestamptz
    swap_id: bigint
    timestamp: timestamptz
    to_address: String
    token_description: String
    token_id: String
    token_name: String
    total_price: bigint
    type: String
}

"aggregate stddev on columns"
type events_stddev_fields {
    amount: Float
    ask_id: Float
    auction_id: Float
    bid: Float
    bid_id: Float
    collection_id: Float
    current_price: Float
    editions: Float
    end_price: Float
    extension_time: Float
    issuer_id: Float
    iteration: Float
    kalamint_edition: Float
    kalamint_editions: Float
    level: Float
    offer_id: Float
    opid: Float
    price: Float
    price_increment: Float
    reserve: Float
    royalties: Float
    start_price: Float
    swap_id: Float
    total_price: Float
}

"aggregate stddev_pop on columns"
type events_stddev_pop_fields {
    amount: Float
    ask_id: Float
    auction_id: Float
    bid: Float
    bid_id: Float
    collection_id: Float
    current_price: Float
    editions: Float
    end_price: Float
    extension_time: Float
    issuer_id: Float
    iteration: Float
    kalamint_edition: Float
    kalamint_editions: Float
    level: Float
    offer_id: Float
    opid: Float
    price: Float
    price_increment: Float
    reserve: Float
    royalties: Float
    start_price: Float
    swap_id: Float
    total_price: Float
}

"aggregate stddev_samp on columns"
type events_stddev_samp_fields {
    amount: Float
    ask_id: Float
    auction_id: Float
    bid: Float
    bid_id: Float
    collection_id: Float
    current_price: Float
    editions: Float
    end_price: Float
    extension_time: Float
    issuer_id: Float
    iteration: Float
    kalamint_edition: Float
    kalamint_editions: Float
    level: Float
    offer_id: Float
    opid: Float
    price: Float
    price_increment: Float
    reserve: Float
    royalties: Float
    start_price: Float
    swap_id: Float
    total_price: Float
}

"aggregate sum on columns"
type events_sum_fields {
    amount: bigint
    ask_id: bigint
    auction_id: bigint
    bid: bigint
    bid_id: bigint
    collection_id: bigint
    current_price: bigint
    editions: bigint
    end_price: bigint
    extension_time: bigint
    issuer_id: bigint
    iteration: bigint
    kalamint_edition: bigint
    kalamint_editions: bigint
    level: bigint
    offer_id: bigint
    opid: bigint
    price: bigint
    price_increment: bigint
    reserve: bigint
    royalties: bigint
    start_price: bigint
    swap_id: bigint
    total_price: bigint
}

"aggregate var_pop on columns"
type events_var_pop_fields {
    amount: Float
    ask_id: Float
    auction_id: Float
    bid: Float
    bid_id: Float
    collection_id: Float
    current_price: Float
    editions: Float
    end_price: Float
    extension_time: Float
    issuer_id: Float
    iteration: Float
    kalamint_edition: Float
    kalamint_editions: Float
    level: Float
    offer_id: Float
    opid: Float
    price: Float
    price_increment: Float
    reserve: Float
    royalties: Float
    start_price: Float
    swap_id: Float
    total_price: Float
}

"aggregate var_samp on columns"
type events_var_samp_fields {
    amount: Float
    ask_id: Float
    auction_id: Float
    bid: Float
    bid_id: Float
    collection_id: Float
    current_price: Float
    editions: Float
    end_price: Float
    extension_time: Float
    issuer_id: Float
    iteration: Float
    kalamint_edition: Float
    kalamint_editions: Float
    level: Float
    offer_id: Float
    opid: Float
    price: Float
    price_increment: Float
    reserve: Float
    royalties: Float
    start_price: Float
    swap_id: Float
    total_price: Float
}

"aggregate variance on columns"
type events_variance_fields {
    amount: Float
    ask_id: Float
    auction_id: Float
    bid: Float
    bid_id: Float
    collection_id: Float
    current_price: Float
    editions: Float
    end_price: Float
    extension_time: Float
    issuer_id: Float
    iteration: Float
    kalamint_edition: Float
    kalamint_editions: Float
    level: Float
    offer_id: Float
    opid: Float
    price: Float
    price_increment: Float
    reserve: Float
    royalties: Float
    start_price: Float
    swap_id: Float
    total_price: Float
}

"columns and relationships of \"holdings\""
type holdings {
    amount: bigint!
    fa2_address: String!
    first_received_at: timestamptz
    holder_address: String!
    "An object relationship"
    holder_profile: tzprofiles
    last_received_at: timestamptz
    "An object relationship"
    token: tokens
    token_id: String!
}

"aggregated selection of \"holdings\""
type holdings_aggregate {
    aggregate: holdings_aggregate_fields
    nodes: [holdings!]!
}

"aggregate fields of \"holdings\""
type holdings_aggregate_fields {
    avg: holdings_avg_fields
    count(columns: [holdings_select_column!], distinct: Boolean): Int!
    max: holdings_max_fields
    min: holdings_min_fields
    stddev: holdings_stddev_fields
    stddev_pop: holdings_stddev_pop_fields
    stddev_samp: holdings_stddev_samp_fields
    sum: holdings_sum_fields
    var_pop: holdings_var_pop_fields
    var_samp: holdings_var_samp_fields
    variance: holdings_variance_fields
}

"aggregate avg on columns"
type holdings_avg_fields {
    amount: Float
}

"aggregate max on columns"
type holdings_max_fields {
    amount: bigint
    fa2_address: String
    first_received_at: timestamptz
    holder_address: String
    last_received_at: timestamptz
    token_id: String
}

"aggregate min on columns"
type holdings_min_fields {
    amount: bigint
    fa2_address: String
    first_received_at: timestamptz
    holder_address: String
    last_received_at: timestamptz
    token_id: String
}

"aggregate stddev on columns"
type holdings_stddev_fields {
    amount: Float
}

"aggregate stddev_pop on columns"
type holdings_stddev_pop_fields {
    amount: Float
}

"aggregate stddev_samp on columns"
type holdings_stddev_samp_fields {
    amount: Float
}

"aggregate sum on columns"
type holdings_sum_fields {
    amount: bigint
}

"aggregate var_pop on columns"
type holdings_var_pop_fields {
    amount: Float
}

"aggregate var_samp on columns"
type holdings_var_samp_fields {
    amount: Float
}

"aggregate variance on columns"
type holdings_variance_fields {
    amount: Float
}

"columns and relationships of \"listings\""
type listings {
    amount: bigint!
    amount_left: bigint!
    ask_id: bigint
    burn_on_end: Boolean
    contract_address: String!
    created_at: timestamptz!
    currency: String
    end_price: bigint
    end_time: timestamptz
    fa2_address: String!
    offer_id: bigint
    price: bigint!
    seller_address: String!
    "An object relationship"
    seller_profile: tzprofiles
    start_price: bigint
    status: String!
    swap_id: bigint
    "An object relationship"
    token: tokens
    token_id: String!
    type: String!
}

"aggregated selection of \"listings\""
type listings_aggregate {
    aggregate: listings_aggregate_fields
    nodes: [listings!]!
}

"aggregate fields of \"listings\""
type listings_aggregate_fields {
    avg: listings_avg_fields
    count(columns: [listings_select_column!], distinct: Boolean): Int!
    max: listings_max_fields
    min: listings_min_fields
    stddev: listings_stddev_fields
    stddev_pop: listings_stddev_pop_fields
    stddev_samp: listings_stddev_samp_fields
    sum: listings_sum_fields
    var_pop: listings_var_pop_fields
    var_samp: listings_var_samp_fields
    variance: listings_variance_fields
}

"aggregate avg on columns"
type listings_avg_fields {
    amount: Float
    amount_left: Float
    ask_id: Float
    end_price: Float
    offer_id: Float
    price: Float
    start_price: Float
    swap_id: Float
}

"aggregate max on columns"
type listings_max_fields {
    amount: bigint
    amount_left: bigint
    ask_id: bigint
    contract_address: String
    created_at: timestamptz
    currency: String
    end_price: bigint
    end_time: timestamptz
    fa2_address: String
    offer_id: bigint
    price: bigint
    seller_address: String
    start_price: bigint
    status: String
    swap_id: bigint
    token_id: String
    type: String
}

"aggregate min on columns"
type listings_min_fields {
    amount: bigint
    amount_left: bigint
    ask_id: bigint
    contract_address: String
    created_at: timestamptz
    currency: String
    end_price: bigint
    end_time: timestamptz
    fa2_address: String
    offer_id: bigint
    price: bigint
    seller_address: String
    start_price: bigint
    status: String
    swap_id: bigint
    token_id: String
    type: String
}

"aggregate stddev on columns"
type listings_stddev_fields {
    amount: Float
    amount_left: Float
    ask_id: Float
    end_price: Float
    offer_id: Float
    price: Float
    start_price: Float
    swap_id: Float
}

"aggregate stddev_pop on columns"
type listings_stddev_pop_fields {
    amount: Float
    amount_left: Float
    ask_id: Float
    end_price: Float
    offer_id: Float
    price: Float
    start_price: Float
    swap_id: Float
}

"aggregate stddev_samp on columns"
type listings_stddev_samp_fields {
    amount: Float
    amount_left: Float
    ask_id: Float
    end_price: Float
    offer_id: Float
    price: Float
    start_price: Float
    swap_id: Float
}

"aggregate sum on columns"
type listings_sum_fields {
    amount: bigint
    amount_left: bigint
    ask_id: bigint
    end_price: bigint
    offer_id: bigint
    price: bigint
    start_price: bigint
    swap_id: bigint
}

"aggregate var_pop on columns"
type listings_var_pop_fields {
    amount: Float
    amount_left: Float
    ask_id: Float
    end_price: Float
    offer_id: Float
    price: Float
    start_price: Float
    swap_id: Float
}

"aggregate var_samp on columns"
type listings_var_samp_fields {
    amount: Float
    amount_left: Float
    ask_id: Float
    end_price: Float
    offer_id: Float
    price: Float
    start_price: Float
    swap_id: Float
}

"aggregate variance on columns"
type listings_variance_fields {
    amount: Float
    amount_left: Float
    ask_id: Float
    end_price: Float
    offer_id: Float
    price: Float
    start_price: Float
    swap_id: Float
}

"columns and relationships of \"offers\""
type offers {
    amount: bigint
    bid_id: bigint
    buyer_address: String!
    "An object relationship"
    buyer_profile: tzprofiles
    contract_address: String!
    created_at: timestamptz!
    currency: String
    fa2_address: String!
    offer_id: bigint
    price: bigint!
    status: String!
    "An object relationship"
    token: tokens
    token_id: String!
    type: String!
}

"aggregated selection of \"offers\""
type offers_aggregate {
    aggregate: offers_aggregate_fields
    nodes: [offers!]!
}

"aggregate fields of \"offers\""
type offers_aggregate_fields {
    avg: offers_avg_fields
    count(columns: [offers_select_column!], distinct: Boolean): Int!
    max: offers_max_fields
    min: offers_min_fields
    stddev: offers_stddev_fields
    stddev_pop: offers_stddev_pop_fields
    stddev_samp: offers_stddev_samp_fields
    sum: offers_sum_fields
    var_pop: offers_var_pop_fields
    var_samp: offers_var_samp_fields
    variance: offers_variance_fields
}

"aggregate avg on columns"
type offers_avg_fields {
    amount: Float
    bid_id: Float
    offer_id: Float
    price: Float
}

"aggregate max on columns"
type offers_max_fields {
    amount: bigint
    bid_id: bigint
    buyer_address: String
    contract_address: String
    created_at: timestamptz
    currency: String
    fa2_address: String
    offer_id: bigint
    price: bigint
    status: String
    token_id: String
    type: String
}

"aggregate min on columns"
type offers_min_fields {
    amount: bigint
    bid_id: bigint
    buyer_address: String
    contract_address: String
    created_at: timestamptz
    currency: String
    fa2_address: String
    offer_id: bigint
    price: bigint
    status: String
    token_id: String
    type: String
}

"aggregate stddev on columns"
type offers_stddev_fields {
    amount: Float
    bid_id: Float
    offer_id: Float
    price: Float
}

"aggregate stddev_pop on columns"
type offers_stddev_pop_fields {
    amount: Float
    bid_id: Float
    offer_id: Float
    price: Float
}

"aggregate stddev_samp on columns"
type offers_stddev_samp_fields {
    amount: Float
    bid_id: Float
    offer_id: Float
    price: Float
}

"aggregate sum on columns"
type offers_sum_fields {
    amount: bigint
    bid_id: bigint
    offer_id: bigint
    price: bigint
}

"aggregate var_pop on columns"
type offers_var_pop_fields {
    amount: Float
    bid_id: Float
    offer_id: Float
    price: Float
}

"aggregate var_samp on columns"
type offers_var_samp_fields {
    amount: Float
    bid_id: Float
    offer_id: Float
    price: Float
}

"aggregate variance on columns"
type offers_variance_fields {
    amount: Float
    bid_id: Float
    offer_id: Float
    price: Float
}

type query_root {
    "An array relationship"
    events(
        "distinct select on columns"
        distinct_on: [events_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [events_order_by!],
        "filter the rows returned"
        where: events_bool_exp
    ): [events!]!
    "An aggregate relationship"
    events_aggregate(
        "distinct select on columns"
        distinct_on: [events_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [events_order_by!],
        "filter the rows returned"
        where: events_bool_exp
    ): events_aggregate!
    "fetch data from the table: \"events\" using primary key columns"
    events_by_pk(id: String!): events
    "An array relationship"
    holdings(
        "distinct select on columns"
        distinct_on: [holdings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [holdings_order_by!],
        "filter the rows returned"
        where: holdings_bool_exp
    ): [holdings!]!
    "An aggregate relationship"
    holdings_aggregate(
        "distinct select on columns"
        distinct_on: [holdings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [holdings_order_by!],
        "filter the rows returned"
        where: holdings_bool_exp
    ): holdings_aggregate!
    "fetch data from the table: \"holdings\" using primary key columns"
    holdings_by_pk(fa2_address: String!, holder_address: String!, token_id: String!): holdings
    "An array relationship"
    listings(
        "distinct select on columns"
        distinct_on: [listings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [listings_order_by!],
        "filter the rows returned"
        where: listings_bool_exp
    ): [listings!]!
    "An aggregate relationship"
    listings_aggregate(
        "distinct select on columns"
        distinct_on: [listings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [listings_order_by!],
        "filter the rows returned"
        where: listings_bool_exp
    ): listings_aggregate!
    "fetch data from the table: \"offers\""
    offers(
        "distinct select on columns"
        distinct_on: [offers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [offers_order_by!],
        "filter the rows returned"
        where: offers_bool_exp
    ): [offers!]!
    "An aggregate relationship"
    offers_aggregate(
        "distinct select on columns"
        distinct_on: [offers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [offers_order_by!],
        "filter the rows returned"
        where: offers_bool_exp
    ): offers_aggregate!
    "An array relationship"
    royalty_receivers(
        "distinct select on columns"
        distinct_on: [royalty_receivers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [royalty_receivers_order_by!],
        "filter the rows returned"
        where: royalty_receivers_bool_exp
    ): [royalty_receivers!]!
    "fetch data from the table: \"royalty_receivers\" using primary key columns"
    royalty_receivers_by_pk(fa2_address: String!, receiver_address: String!, token_id: String!): royalty_receivers
    "An array relationship"
    tags(
        "distinct select on columns"
        distinct_on: [tags_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tags_order_by!],
        "filter the rows returned"
        where: tags_bool_exp
    ): [tags!]!
    "An aggregate relationship"
    tags_aggregate(
        "distinct select on columns"
        distinct_on: [tags_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tags_order_by!],
        "filter the rows returned"
        where: tags_bool_exp
    ): tags_aggregate!
    "fetch data from the table: \"tags\" using primary key columns"
    tags_by_pk(fa2_address: String!, tag: String!, token_id: String!): tags
    "fetch data from the table: \"token_metadata\""
    token_metadata(
        "distinct select on columns"
        distinct_on: [token_metadata_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [token_metadata_order_by!],
        "filter the rows returned"
        where: token_metadata_bool_exp
    ): [token_metadata!]!
    "An array relationship"
    tokens(
        "distinct select on columns"
        distinct_on: [tokens_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tokens_order_by!],
        "filter the rows returned"
        where: tokens_bool_exp
    ): [tokens!]!
    "An aggregate relationship"
    tokens_aggregate(
        "distinct select on columns"
        distinct_on: [tokens_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tokens_order_by!],
        "filter the rows returned"
        where: tokens_bool_exp
    ): tokens_aggregate!
    "fetch data from the table: \"tokens\" using primary key columns"
    tokens_by_pk(fa2_address: String!, token_id: String!): tokens
    "fetch data from the table: \"tzprofiles.tzprofiles\""
    tzprofiles(
        "distinct select on columns"
        distinct_on: [tzprofiles_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tzprofiles_order_by!],
        "filter the rows returned"
        where: tzprofiles_bool_exp
    ): [tzprofiles!]!
    "fetch aggregated fields from the table: \"tzprofiles.tzprofiles\""
    tzprofiles_aggregate(
        "distinct select on columns"
        distinct_on: [tzprofiles_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tzprofiles_order_by!],
        "filter the rows returned"
        where: tzprofiles_bool_exp
    ): tzprofiles_aggregate!
    "fetch data from the table: \"tzprofiles.tzprofiles\" using primary key columns"
    tzprofiles_by_pk(account: String!): tzprofiles
}

"columns and relationships of \"royalty_receivers\""
type royalty_receivers {
    fa2_address: String!
    receiver_address: String!
    "An object relationship"
    receiver_profile: tzprofiles
    royalties: bigint!
    "An object relationship"
    token: tokens
    token_id: String!
}

type subscription_root {
    "An array relationship"
    events(
        "distinct select on columns"
        distinct_on: [events_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [events_order_by!],
        "filter the rows returned"
        where: events_bool_exp
    ): [events!]!
    "An aggregate relationship"
    events_aggregate(
        "distinct select on columns"
        distinct_on: [events_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [events_order_by!],
        "filter the rows returned"
        where: events_bool_exp
    ): events_aggregate!
    "fetch data from the table: \"events\" using primary key columns"
    events_by_pk(id: String!): events
    "An array relationship"
    holdings(
        "distinct select on columns"
        distinct_on: [holdings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [holdings_order_by!],
        "filter the rows returned"
        where: holdings_bool_exp
    ): [holdings!]!
    "An aggregate relationship"
    holdings_aggregate(
        "distinct select on columns"
        distinct_on: [holdings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [holdings_order_by!],
        "filter the rows returned"
        where: holdings_bool_exp
    ): holdings_aggregate!
    "fetch data from the table: \"holdings\" using primary key columns"
    holdings_by_pk(fa2_address: String!, holder_address: String!, token_id: String!): holdings
    "An array relationship"
    listings(
        "distinct select on columns"
        distinct_on: [listings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [listings_order_by!],
        "filter the rows returned"
        where: listings_bool_exp
    ): [listings!]!
    "An aggregate relationship"
    listings_aggregate(
        "distinct select on columns"
        distinct_on: [listings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [listings_order_by!],
        "filter the rows returned"
        where: listings_bool_exp
    ): listings_aggregate!
    "fetch data from the table: \"offers\""
    offers(
        "distinct select on columns"
        distinct_on: [offers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [offers_order_by!],
        "filter the rows returned"
        where: offers_bool_exp
    ): [offers!]!
    "An aggregate relationship"
    offers_aggregate(
        "distinct select on columns"
        distinct_on: [offers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [offers_order_by!],
        "filter the rows returned"
        where: offers_bool_exp
    ): offers_aggregate!
    "An array relationship"
    royalty_receivers(
        "distinct select on columns"
        distinct_on: [royalty_receivers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [royalty_receivers_order_by!],
        "filter the rows returned"
        where: royalty_receivers_bool_exp
    ): [royalty_receivers!]!
    "fetch data from the table: \"royalty_receivers\" using primary key columns"
    royalty_receivers_by_pk(fa2_address: String!, receiver_address: String!, token_id: String!): royalty_receivers
    "An array relationship"
    tags(
        "distinct select on columns"
        distinct_on: [tags_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tags_order_by!],
        "filter the rows returned"
        where: tags_bool_exp
    ): [tags!]!
    "An aggregate relationship"
    tags_aggregate(
        "distinct select on columns"
        distinct_on: [tags_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tags_order_by!],
        "filter the rows returned"
        where: tags_bool_exp
    ): tags_aggregate!
    "fetch data from the table: \"tags\" using primary key columns"
    tags_by_pk(fa2_address: String!, tag: String!, token_id: String!): tags
    "fetch data from the table: \"token_metadata\""
    token_metadata(
        "distinct select on columns"
        distinct_on: [token_metadata_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [token_metadata_order_by!],
        "filter the rows returned"
        where: token_metadata_bool_exp
    ): [token_metadata!]!
    "An array relationship"
    tokens(
        "distinct select on columns"
        distinct_on: [tokens_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tokens_order_by!],
        "filter the rows returned"
        where: tokens_bool_exp
    ): [tokens!]!
    "An aggregate relationship"
    tokens_aggregate(
        "distinct select on columns"
        distinct_on: [tokens_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tokens_order_by!],
        "filter the rows returned"
        where: tokens_bool_exp
    ): tokens_aggregate!
    "fetch data from the table: \"tokens\" using primary key columns"
    tokens_by_pk(fa2_address: String!, token_id: String!): tokens
    "fetch data from the table: \"tzprofiles.tzprofiles\""
    tzprofiles(
        "distinct select on columns"
        distinct_on: [tzprofiles_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tzprofiles_order_by!],
        "filter the rows returned"
        where: tzprofiles_bool_exp
    ): [tzprofiles!]!
    "fetch aggregated fields from the table: \"tzprofiles.tzprofiles\""
    tzprofiles_aggregate(
        "distinct select on columns"
        distinct_on: [tzprofiles_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tzprofiles_order_by!],
        "filter the rows returned"
        where: tzprofiles_bool_exp
    ): tzprofiles_aggregate!
    "fetch data from the table: \"tzprofiles.tzprofiles\" using primary key columns"
    tzprofiles_by_pk(account: String!): tzprofiles
}

"columns and relationships of \"tags\""
type tags {
    fa2_address: String!
    tag: String!
    "An object relationship"
    token: tokens
    token_id: String!
}

"aggregated selection of \"tags\""
type tags_aggregate {
    aggregate: tags_aggregate_fields
    nodes: [tags!]!
}

"aggregate fields of \"tags\""
type tags_aggregate_fields {
    count(columns: [tags_select_column!], distinct: Boolean): Int!
    max: tags_max_fields
    min: tags_min_fields
}

"aggregate max on columns"
type tags_max_fields {
    fa2_address: String
    tag: String
    token_id: String
}

"aggregate min on columns"
type tags_min_fields {
    fa2_address: String
    tag: String
    token_id: String
}

"columns and relationships of \"token_metadata\""
type token_metadata {
    data(
        "JSON select path"
        path: String
    ): jsonb
    status: String!
    "An array relationship"
    tokens(
        "distinct select on columns"
        distinct_on: [tokens_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tokens_order_by!],
        "filter the rows returned"
        where: tokens_bool_exp
    ): [tokens!]!
    "An aggregate relationship"
    tokens_aggregate(
        "distinct select on columns"
        distinct_on: [tokens_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tokens_order_by!],
        "filter the rows returned"
        where: tokens_bool_exp
    ): tokens_aggregate!
    uri: String!
}

"columns and relationships of \"tokens\""
type tokens {
    artifact_metadata(
        "JSON select path"
        path: String
    ): jsonb
    artifact_uri: String
    artist_address: String
    "An object relationship"
    artist_profile: tzprofiles
    assets(
        "JSON select path"
        path: String
    ): jsonb
    attributes(
        "JSON select path"
        path: String
    ): jsonb
    burned_editions: bigint
    contributors(
        "JSON select path"
        path: String
    ): jsonb
    creators(
        "JSON select path"
        path: String
    ): jsonb
    current_price_to_first_sales_price_diff: bigint
    current_price_to_first_sales_price_pct: bigint
    current_price_to_highest_sales_price_diff: bigint
    current_price_to_highest_sales_price_pct: bigint
    current_price_to_last_sales_price_diff: bigint
    current_price_to_last_sales_price_pct: bigint
    current_price_to_lowest_sales_price_diff: bigint
    current_price_to_lowest_sales_price_pct: bigint
    description: String
    display_uri: String
    editions: bigint
    eightbid_creator_name: String
    eightbid_rgb: String
    eightscribo_rowone: String
    eightscribo_rowthree: String
    eightscribo_rowtwo: String
    eightscribo_title: String
    "An array relationship"
    events(
        "distinct select on columns"
        distinct_on: [events_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [events_order_by!],
        "filter the rows returned"
        where: events_bool_exp
    ): [events!]!
    "An aggregate relationship"
    events_aggregate(
        "distinct select on columns"
        distinct_on: [events_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [events_order_by!],
        "filter the rows returned"
        where: events_bool_exp
    ): events_aggregate!
    external_uri: String
    fa2_address: String!
    first_sales_price: bigint
    formats(
        "JSON select path"
        path: String
    ): jsonb
    fx_collection_description: String
    fx_collection_display_uri: String
    fx_collection_editions: bigint
    fx_collection_name: String
    fx_collection_thumbnail_uri: String
    fx_issuer_id: bigint
    fx_iteration: bigint
    highest_offer_price: bigint
    highest_sales_price: bigint
    "An array relationship"
    holdings(
        "distinct select on columns"
        distinct_on: [holdings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [holdings_order_by!],
        "filter the rows returned"
        where: holdings_bool_exp
    ): [holdings!]!
    "An aggregate relationship"
    holdings_aggregate(
        "distinct select on columns"
        distinct_on: [holdings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [holdings_order_by!],
        "filter the rows returned"
        where: holdings_bool_exp
    ): holdings_aggregate!
    is_verified_artist: Boolean
    last_processed_event_id: String
    last_processed_event_level: bigint
    last_processed_event_timestamp: timestamptz
    last_sale_at: timestamptz
    last_sales_price: bigint
    "An array relationship"
    listings(
        "distinct select on columns"
        distinct_on: [listings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [listings_order_by!],
        "filter the rows returned"
        where: listings_bool_exp
    ): [listings!]!
    "An aggregate relationship"
    listings_aggregate(
        "distinct select on columns"
        distinct_on: [listings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [listings_order_by!],
        "filter the rows returned"
        where: listings_bool_exp
    ): listings_aggregate!
    lowest_price_listing(
        "JSON select path"
        path: String
    ): jsonb
    lowest_sales_price: bigint
    "An object relationship"
    metadata: token_metadata
    metadata_status: String!
    metadata_uri: String
    mime_type: String
    mint_price: bigint
    minted_at: timestamptz
    minter_address: String
    "An object relationship"
    minter_profile: tzprofiles
    name: String
    objkt_artist_collection_id: bigint
    "fetch data from the table: \"offers\""
    offers(
        "distinct select on columns"
        distinct_on: [offers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [offers_order_by!],
        "filter the rows returned"
        where: offers_bool_exp
    ): [offers!]!
    "An aggregate relationship"
    offers_aggregate(
        "distinct select on columns"
        distinct_on: [offers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [offers_order_by!],
        "filter the rows returned"
        where: offers_bool_exp
    ): offers_aggregate!
    platform: String
    price: bigint
    right_uri: String
    rights: String
    royalties(
        "JSON select path"
        path: String
    ): jsonb
    royalties_total: bigint
    "An array relationship"
    royalty_receivers(
        "distinct select on columns"
        distinct_on: [royalty_receivers_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [royalty_receivers_order_by!],
        "filter the rows returned"
        where: royalty_receivers_bool_exp
    ): [royalty_receivers!]!
    sales_count: bigint
    sales_volume: bigint
    symbol: String
    "An array relationship"
    tags(
        "distinct select on columns"
        distinct_on: [tags_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tags_order_by!],
        "filter the rows returned"
        where: tags_bool_exp
    ): [tags!]!
    "An aggregate relationship"
    tags_aggregate(
        "distinct select on columns"
        distinct_on: [tags_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tags_order_by!],
        "filter the rows returned"
        where: tags_bool_exp
    ): tags_aggregate!
    thumbnail_uri: String
    token_id: String!
    updated_at: timestamptz
}

"aggregated selection of \"tokens\""
type tokens_aggregate {
    aggregate: tokens_aggregate_fields
    nodes: [tokens!]!
}

"aggregate fields of \"tokens\""
type tokens_aggregate_fields {
    avg: tokens_avg_fields
    count(columns: [tokens_select_column!], distinct: Boolean): Int!
    max: tokens_max_fields
    min: tokens_min_fields
    stddev: tokens_stddev_fields
    stddev_pop: tokens_stddev_pop_fields
    stddev_samp: tokens_stddev_samp_fields
    sum: tokens_sum_fields
    var_pop: tokens_var_pop_fields
    var_samp: tokens_var_samp_fields
    variance: tokens_variance_fields
}

"aggregate avg on columns"
type tokens_avg_fields {
    burned_editions: Float
    current_price_to_first_sales_price_diff: Float
    current_price_to_first_sales_price_pct: Float
    current_price_to_highest_sales_price_diff: Float
    current_price_to_highest_sales_price_pct: Float
    current_price_to_last_sales_price_diff: Float
    current_price_to_last_sales_price_pct: Float
    current_price_to_lowest_sales_price_diff: Float
    current_price_to_lowest_sales_price_pct: Float
    editions: Float
    first_sales_price: Float
    fx_collection_editions: Float
    fx_issuer_id: Float
    fx_iteration: Float
    highest_offer_price: Float
    highest_sales_price: Float
    last_processed_event_level: Float
    last_sales_price: Float
    lowest_sales_price: Float
    mint_price: Float
    objkt_artist_collection_id: Float
    price: Float
    royalties_total: Float
    sales_count: Float
    sales_volume: Float
}

"aggregate max on columns"
type tokens_max_fields {
    artifact_uri: String
    artist_address: String
    burned_editions: bigint
    current_price_to_first_sales_price_diff: bigint
    current_price_to_first_sales_price_pct: bigint
    current_price_to_highest_sales_price_diff: bigint
    current_price_to_highest_sales_price_pct: bigint
    current_price_to_last_sales_price_diff: bigint
    current_price_to_last_sales_price_pct: bigint
    current_price_to_lowest_sales_price_diff: bigint
    current_price_to_lowest_sales_price_pct: bigint
    description: String
    display_uri: String
    editions: bigint
    eightbid_creator_name: String
    eightbid_rgb: String
    eightscribo_rowone: String
    eightscribo_rowthree: String
    eightscribo_rowtwo: String
    eightscribo_title: String
    external_uri: String
    fa2_address: String
    first_sales_price: bigint
    fx_collection_description: String
    fx_collection_display_uri: String
    fx_collection_editions: bigint
    fx_collection_name: String
    fx_collection_thumbnail_uri: String
    fx_issuer_id: bigint
    fx_iteration: bigint
    highest_offer_price: bigint
    highest_sales_price: bigint
    last_processed_event_id: String
    last_processed_event_level: bigint
    last_processed_event_timestamp: timestamptz
    last_sale_at: timestamptz
    last_sales_price: bigint
    lowest_sales_price: bigint
    metadata_status: String
    metadata_uri: String
    mime_type: String
    mint_price: bigint
    minted_at: timestamptz
    minter_address: String
    name: String
    objkt_artist_collection_id: bigint
    platform: String
    price: bigint
    right_uri: String
    rights: String
    royalties_total: bigint
    sales_count: bigint
    sales_volume: bigint
    symbol: String
    thumbnail_uri: String
    token_id: String
    updated_at: timestamptz
}

"aggregate min on columns"
type tokens_min_fields {
    artifact_uri: String
    artist_address: String
    burned_editions: bigint
    current_price_to_first_sales_price_diff: bigint
    current_price_to_first_sales_price_pct: bigint
    current_price_to_highest_sales_price_diff: bigint
    current_price_to_highest_sales_price_pct: bigint
    current_price_to_last_sales_price_diff: bigint
    current_price_to_last_sales_price_pct: bigint
    current_price_to_lowest_sales_price_diff: bigint
    current_price_to_lowest_sales_price_pct: bigint
    description: String
    display_uri: String
    editions: bigint
    eightbid_creator_name: String
    eightbid_rgb: String
    eightscribo_rowone: String
    eightscribo_rowthree: String
    eightscribo_rowtwo: String
    eightscribo_title: String
    external_uri: String
    fa2_address: String
    first_sales_price: bigint
    fx_collection_description: String
    fx_collection_display_uri: String
    fx_collection_editions: bigint
    fx_collection_name: String
    fx_collection_thumbnail_uri: String
    fx_issuer_id: bigint
    fx_iteration: bigint
    highest_offer_price: bigint
    highest_sales_price: bigint
    last_processed_event_id: String
    last_processed_event_level: bigint
    last_processed_event_timestamp: timestamptz
    last_sale_at: timestamptz
    last_sales_price: bigint
    lowest_sales_price: bigint
    metadata_status: String
    metadata_uri: String
    mime_type: String
    mint_price: bigint
    minted_at: timestamptz
    minter_address: String
    name: String
    objkt_artist_collection_id: bigint
    platform: String
    price: bigint
    right_uri: String
    rights: String
    royalties_total: bigint
    sales_count: bigint
    sales_volume: bigint
    symbol: String
    thumbnail_uri: String
    token_id: String
    updated_at: timestamptz
}

"aggregate stddev on columns"
type tokens_stddev_fields {
    burned_editions: Float
    current_price_to_first_sales_price_diff: Float
    current_price_to_first_sales_price_pct: Float
    current_price_to_highest_sales_price_diff: Float
    current_price_to_highest_sales_price_pct: Float
    current_price_to_last_sales_price_diff: Float
    current_price_to_last_sales_price_pct: Float
    current_price_to_lowest_sales_price_diff: Float
    current_price_to_lowest_sales_price_pct: Float
    editions: Float
    first_sales_price: Float
    fx_collection_editions: Float
    fx_issuer_id: Float
    fx_iteration: Float
    highest_offer_price: Float
    highest_sales_price: Float
    last_processed_event_level: Float
    last_sales_price: Float
    lowest_sales_price: Float
    mint_price: Float
    objkt_artist_collection_id: Float
    price: Float
    royalties_total: Float
    sales_count: Float
    sales_volume: Float
}

"aggregate stddev_pop on columns"
type tokens_stddev_pop_fields {
    burned_editions: Float
    current_price_to_first_sales_price_diff: Float
    current_price_to_first_sales_price_pct: Float
    current_price_to_highest_sales_price_diff: Float
    current_price_to_highest_sales_price_pct: Float
    current_price_to_last_sales_price_diff: Float
    current_price_to_last_sales_price_pct: Float
    current_price_to_lowest_sales_price_diff: Float
    current_price_to_lowest_sales_price_pct: Float
    editions: Float
    first_sales_price: Float
    fx_collection_editions: Float
    fx_issuer_id: Float
    fx_iteration: Float
    highest_offer_price: Float
    highest_sales_price: Float
    last_processed_event_level: Float
    last_sales_price: Float
    lowest_sales_price: Float
    mint_price: Float
    objkt_artist_collection_id: Float
    price: Float
    royalties_total: Float
    sales_count: Float
    sales_volume: Float
}

"aggregate stddev_samp on columns"
type tokens_stddev_samp_fields {
    burned_editions: Float
    current_price_to_first_sales_price_diff: Float
    current_price_to_first_sales_price_pct: Float
    current_price_to_highest_sales_price_diff: Float
    current_price_to_highest_sales_price_pct: Float
    current_price_to_last_sales_price_diff: Float
    current_price_to_last_sales_price_pct: Float
    current_price_to_lowest_sales_price_diff: Float
    current_price_to_lowest_sales_price_pct: Float
    editions: Float
    first_sales_price: Float
    fx_collection_editions: Float
    fx_issuer_id: Float
    fx_iteration: Float
    highest_offer_price: Float
    highest_sales_price: Float
    last_processed_event_level: Float
    last_sales_price: Float
    lowest_sales_price: Float
    mint_price: Float
    objkt_artist_collection_id: Float
    price: Float
    royalties_total: Float
    sales_count: Float
    sales_volume: Float
}

"aggregate sum on columns"
type tokens_sum_fields {
    burned_editions: bigint
    current_price_to_first_sales_price_diff: bigint
    current_price_to_first_sales_price_pct: bigint
    current_price_to_highest_sales_price_diff: bigint
    current_price_to_highest_sales_price_pct: bigint
    current_price_to_last_sales_price_diff: bigint
    current_price_to_last_sales_price_pct: bigint
    current_price_to_lowest_sales_price_diff: bigint
    current_price_to_lowest_sales_price_pct: bigint
    editions: bigint
    first_sales_price: bigint
    fx_collection_editions: bigint
    fx_issuer_id: bigint
    fx_iteration: bigint
    highest_offer_price: bigint
    highest_sales_price: bigint
    last_processed_event_level: bigint
    last_sales_price: bigint
    lowest_sales_price: bigint
    mint_price: bigint
    objkt_artist_collection_id: bigint
    price: bigint
    royalties_total: bigint
    sales_count: bigint
    sales_volume: bigint
}

"aggregate var_pop on columns"
type tokens_var_pop_fields {
    burned_editions: Float
    current_price_to_first_sales_price_diff: Float
    current_price_to_first_sales_price_pct: Float
    current_price_to_highest_sales_price_diff: Float
    current_price_to_highest_sales_price_pct: Float
    current_price_to_last_sales_price_diff: Float
    current_price_to_last_sales_price_pct: Float
    current_price_to_lowest_sales_price_diff: Float
    current_price_to_lowest_sales_price_pct: Float
    editions: Float
    first_sales_price: Float
    fx_collection_editions: Float
    fx_issuer_id: Float
    fx_iteration: Float
    highest_offer_price: Float
    highest_sales_price: Float
    last_processed_event_level: Float
    last_sales_price: Float
    lowest_sales_price: Float
    mint_price: Float
    objkt_artist_collection_id: Float
    price: Float
    royalties_total: Float
    sales_count: Float
    sales_volume: Float
}

"aggregate var_samp on columns"
type tokens_var_samp_fields {
    burned_editions: Float
    current_price_to_first_sales_price_diff: Float
    current_price_to_first_sales_price_pct: Float
    current_price_to_highest_sales_price_diff: Float
    current_price_to_highest_sales_price_pct: Float
    current_price_to_last_sales_price_diff: Float
    current_price_to_last_sales_price_pct: Float
    current_price_to_lowest_sales_price_diff: Float
    current_price_to_lowest_sales_price_pct: Float
    editions: Float
    first_sales_price: Float
    fx_collection_editions: Float
    fx_issuer_id: Float
    fx_iteration: Float
    highest_offer_price: Float
    highest_sales_price: Float
    last_processed_event_level: Float
    last_sales_price: Float
    lowest_sales_price: Float
    mint_price: Float
    objkt_artist_collection_id: Float
    price: Float
    royalties_total: Float
    sales_count: Float
    sales_volume: Float
}

"aggregate variance on columns"
type tokens_variance_fields {
    burned_editions: Float
    current_price_to_first_sales_price_diff: Float
    current_price_to_first_sales_price_pct: Float
    current_price_to_highest_sales_price_diff: Float
    current_price_to_highest_sales_price_pct: Float
    current_price_to_last_sales_price_diff: Float
    current_price_to_last_sales_price_pct: Float
    current_price_to_lowest_sales_price_diff: Float
    current_price_to_lowest_sales_price_pct: Float
    editions: Float
    first_sales_price: Float
    fx_collection_editions: Float
    fx_issuer_id: Float
    fx_iteration: Float
    highest_offer_price: Float
    highest_sales_price: Float
    last_processed_event_level: Float
    last_sales_price: Float
    lowest_sales_price: Float
    mint_price: Float
    objkt_artist_collection_id: Float
    price: Float
    royalties_total: Float
    sales_count: Float
    sales_volume: Float
}

"columns and relationships of \"tzprofiles.tzprofiles\""
type tzprofiles {
    account: String!
    alias: String
    contract: String!
    description: String
    discord: String
    domain_name: String
    ethereum: String
    github: String
    logo: String
    twitter: String
    website: String
}

"aggregated selection of \"tzprofiles.tzprofiles\""
type tzprofiles_aggregate {
    aggregate: tzprofiles_aggregate_fields
    nodes: [tzprofiles!]!
}

"aggregate fields of \"tzprofiles.tzprofiles\""
type tzprofiles_aggregate_fields {
    count(columns: [tzprofiles_select_column!], distinct: Boolean): Int!
    max: tzprofiles_max_fields
    min: tzprofiles_min_fields
}

"aggregate max on columns"
type tzprofiles_max_fields {
    account: String
    alias: String
    contract: String
    description: String
    discord: String
    domain_name: String
    ethereum: String
    github: String
    logo: String
    twitter: String
    website: String
}

"aggregate min on columns"
type tzprofiles_min_fields {
    account: String
    alias: String
    contract: String
    description: String
    discord: String
    domain_name: String
    ethereum: String
    github: String
    logo: String
    twitter: String
    website: String
}

"select columns of table \"events\""
enum events_select_column {
    "column name"
    amount
    "column name"
    artist_address
    "column name"
    ask_id
    "column name"
    auction_id
    "column name"
    bid
    "column name"
    bid_id
    "column name"
    bidder_address
    "column name"
    burn_on_end
    "column name"
    buyer_address
    "column name"
    collection_id
    "column name"
    creator_name
    "column name"
    currency
    "column name"
    current_price
    "column name"
    editions
    "column name"
    eightscribo_rowone
    "column name"
    eightscribo_rowthree
    "column name"
    eightscribo_rowtwo
    "column name"
    eightscribo_title
    "column name"
    end_price
    "column name"
    end_time
    "column name"
    extension_time
    "column name"
    fa2_address
    "column name"
    from_address
    "column name"
    highest_bidder_address
    "column name"
    holder_address
    "column name"
    id
    "column name"
    implements
    "column name"
    is_mint
    "column name"
    is_verified_artist
    "column name"
    issuer_id
    "column name"
    iteration
    "column name"
    kalamint_edition
    "column name"
    kalamint_editions
    "column name"
    ledger_type
    "column name"
    level
    "column name"
    metadata
    "column name"
    metadata_uri
    "column name"
    offer_id
    "column name"
    ophash
    "column name"
    opid
    "column name"
    owner_address
    "column name"
    price
    "column name"
    price_increment
    "column name"
    reserve
    "column name"
    rgb
    "column name"
    royalties
    "column name"
    royalty_shares
    "column name"
    seller_address
    "column name"
    start_price
    "column name"
    start_time
    "column name"
    swap_id
    "column name"
    timestamp
    "column name"
    to_address
    "column name"
    token_description
    "column name"
    token_id
    "column name"
    token_name
    "column name"
    total_price
    "column name"
    type
}

"select columns of table \"holdings\""
enum holdings_select_column {
    "column name"
    amount
    "column name"
    fa2_address
    "column name"
    first_received_at
    "column name"
    holder_address
    "column name"
    last_received_at
    "column name"
    token_id
}

"select columns of table \"listings\""
enum listings_select_column {
    "column name"
    amount
    "column name"
    amount_left
    "column name"
    ask_id
    "column name"
    burn_on_end
    "column name"
    contract_address
    "column name"
    created_at
    "column name"
    currency
    "column name"
    end_price
    "column name"
    end_time
    "column name"
    fa2_address
    "column name"
    offer_id
    "column name"
    price
    "column name"
    seller_address
    "column name"
    start_price
    "column name"
    status
    "column name"
    swap_id
    "column name"
    token_id
    "column name"
    type
}

"select columns of table \"offers\""
enum offers_select_column {
    "column name"
    amount
    "column name"
    bid_id
    "column name"
    buyer_address
    "column name"
    contract_address
    "column name"
    created_at
    "column name"
    currency
    "column name"
    fa2_address
    "column name"
    offer_id
    "column name"
    price
    "column name"
    status
    "column name"
    token_id
    "column name"
    type
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

"select columns of table \"royalty_receivers\""
enum royalty_receivers_select_column {
    "column name"
    fa2_address
    "column name"
    receiver_address
    "column name"
    royalties
    "column name"
    token_id
}

"select columns of table \"tags\""
enum tags_select_column {
    "column name"
    fa2_address
    "column name"
    tag
    "column name"
    token_id
}

"select columns of table \"token_metadata\""
enum token_metadata_select_column {
    "column name"
    data
    "column name"
    status
    "column name"
    uri
}

"select columns of table \"tokens\""
enum tokens_select_column {
    "column name"
    artifact_metadata
    "column name"
    artifact_uri
    "column name"
    artist_address
    "column name"
    assets
    "column name"
    attributes
    "column name"
    burned_editions
    "column name"
    contributors
    "column name"
    creators
    "column name"
    current_price_to_first_sales_price_diff
    "column name"
    current_price_to_first_sales_price_pct
    "column name"
    current_price_to_highest_sales_price_diff
    "column name"
    current_price_to_highest_sales_price_pct
    "column name"
    current_price_to_last_sales_price_diff
    "column name"
    current_price_to_last_sales_price_pct
    "column name"
    current_price_to_lowest_sales_price_diff
    "column name"
    current_price_to_lowest_sales_price_pct
    "column name"
    description
    "column name"
    display_uri
    "column name"
    editions
    "column name"
    eightbid_creator_name
    "column name"
    eightbid_rgb
    "column name"
    eightscribo_rowone
    "column name"
    eightscribo_rowthree
    "column name"
    eightscribo_rowtwo
    "column name"
    eightscribo_title
    "column name"
    external_uri
    "column name"
    fa2_address
    "column name"
    first_sales_price
    "column name"
    formats
    "column name"
    fx_collection_description
    "column name"
    fx_collection_display_uri
    "column name"
    fx_collection_editions
    "column name"
    fx_collection_name
    "column name"
    fx_collection_thumbnail_uri
    "column name"
    fx_issuer_id
    "column name"
    fx_iteration
    "column name"
    highest_offer_price
    "column name"
    highest_sales_price
    "column name"
    is_verified_artist
    "column name"
    last_processed_event_id
    "column name"
    last_processed_event_level
    "column name"
    last_processed_event_timestamp
    "column name"
    last_sale_at
    "column name"
    last_sales_price
    "column name"
    lowest_price_listing
    "column name"
    lowest_sales_price
    "column name"
    metadata_status
    "column name"
    metadata_uri
    "column name"
    mime_type
    "column name"
    mint_price
    "column name"
    minted_at
    "column name"
    minter_address
    "column name"
    name
    "column name"
    objkt_artist_collection_id
    "column name"
    platform
    "column name"
    price
    "column name"
    right_uri
    "column name"
    rights
    "column name"
    royalties
    "column name"
    royalties_total
    "column name"
    sales_count
    "column name"
    sales_volume
    "column name"
    symbol
    "column name"
    thumbnail_uri
    "column name"
    token_id
    "column name"
    updated_at
}

"select columns of table \"tzprofiles.tzprofiles\""
enum tzprofiles_select_column {
    "column name"
    account
    "column name"
    alias
    "column name"
    contract
    "column name"
    description
    "column name"
    discord
    "column name"
    domain_name
    "column name"
    ethereum
    "column name"
    github
    "column name"
    logo
    "column name"
    twitter
    "column name"
    website
}

scalar bigint

scalar jsonb

scalar timestamptz

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _is_null: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
    _eq: bigint
    _gt: bigint
    _gte: bigint
    _in: [bigint!]
    _is_null: Boolean
    _lt: bigint
    _lte: bigint
    _neq: bigint
    _nin: [bigint!]
}

"order by aggregate values of table \"events\""
input events_aggregate_order_by {
    avg: events_avg_order_by
    count: order_by
    max: events_max_order_by
    min: events_min_order_by
    stddev: events_stddev_order_by
    stddev_pop: events_stddev_pop_order_by
    stddev_samp: events_stddev_samp_order_by
    sum: events_sum_order_by
    var_pop: events_var_pop_order_by
    var_samp: events_var_samp_order_by
    variance: events_variance_order_by
}

"order by avg() on columns of table \"events\""
input events_avg_order_by {
    amount: order_by
    ask_id: order_by
    auction_id: order_by
    bid: order_by
    bid_id: order_by
    collection_id: order_by
    current_price: order_by
    editions: order_by
    end_price: order_by
    extension_time: order_by
    issuer_id: order_by
    iteration: order_by
    kalamint_edition: order_by
    kalamint_editions: order_by
    level: order_by
    offer_id: order_by
    opid: order_by
    price: order_by
    price_increment: order_by
    reserve: order_by
    royalties: order_by
    start_price: order_by
    swap_id: order_by
    total_price: order_by
}

"Boolean expression to filter rows from the table \"events\". All fields are combined with a logical 'AND'."
input events_bool_exp {
    _and: [events_bool_exp!]
    _not: events_bool_exp
    _or: [events_bool_exp!]
    amount: bigint_comparison_exp
    artist_address: String_comparison_exp
    artist_profile: tzprofiles_bool_exp
    ask_id: bigint_comparison_exp
    auction_id: bigint_comparison_exp
    bid: bigint_comparison_exp
    bid_id: bigint_comparison_exp
    bidder_address: String_comparison_exp
    bidder_profile: tzprofiles_bool_exp
    burn_on_end: Boolean_comparison_exp
    buyer_address: String_comparison_exp
    buyer_profile: tzprofiles_bool_exp
    collection_id: bigint_comparison_exp
    creator_name: String_comparison_exp
    currency: String_comparison_exp
    current_price: bigint_comparison_exp
    editions: bigint_comparison_exp
    eightscribo_rowone: String_comparison_exp
    eightscribo_rowthree: String_comparison_exp
    eightscribo_rowtwo: String_comparison_exp
    eightscribo_title: String_comparison_exp
    end_price: bigint_comparison_exp
    end_time: timestamptz_comparison_exp
    extension_time: bigint_comparison_exp
    fa2_address: String_comparison_exp
    from_address: String_comparison_exp
    from_profile: tzprofiles_bool_exp
    highest_bidder_address: String_comparison_exp
    highest_bidder_profile: tzprofiles_bool_exp
    holder_address: String_comparison_exp
    holder_profile: tzprofiles_bool_exp
    id: String_comparison_exp
    implements: String_comparison_exp
    is_mint: Boolean_comparison_exp
    is_verified_artist: Boolean_comparison_exp
    issuer_id: bigint_comparison_exp
    iteration: bigint_comparison_exp
    kalamint_edition: bigint_comparison_exp
    kalamint_editions: bigint_comparison_exp
    ledger_type: String_comparison_exp
    level: bigint_comparison_exp
    metadata: jsonb_comparison_exp
    metadata_uri: String_comparison_exp
    offer_id: bigint_comparison_exp
    ophash: String_comparison_exp
    opid: bigint_comparison_exp
    owner_address: String_comparison_exp
    owner_profile: tzprofiles_bool_exp
    price: bigint_comparison_exp
    price_increment: bigint_comparison_exp
    reserve: bigint_comparison_exp
    rgb: String_comparison_exp
    royalties: bigint_comparison_exp
    royalty_shares: jsonb_comparison_exp
    seller_address: String_comparison_exp
    seller_profile: tzprofiles_bool_exp
    start_price: bigint_comparison_exp
    start_time: timestamptz_comparison_exp
    swap_id: bigint_comparison_exp
    timestamp: timestamptz_comparison_exp
    to_address: String_comparison_exp
    to_profile: tzprofiles_bool_exp
    token: tokens_bool_exp
    token_description: String_comparison_exp
    token_id: String_comparison_exp
    token_name: String_comparison_exp
    total_price: bigint_comparison_exp
    type: String_comparison_exp
}

"order by max() on columns of table \"events\""
input events_max_order_by {
    amount: order_by
    artist_address: order_by
    ask_id: order_by
    auction_id: order_by
    bid: order_by
    bid_id: order_by
    bidder_address: order_by
    buyer_address: order_by
    collection_id: order_by
    creator_name: order_by
    currency: order_by
    current_price: order_by
    editions: order_by
    eightscribo_rowone: order_by
    eightscribo_rowthree: order_by
    eightscribo_rowtwo: order_by
    eightscribo_title: order_by
    end_price: order_by
    end_time: order_by
    extension_time: order_by
    fa2_address: order_by
    from_address: order_by
    highest_bidder_address: order_by
    holder_address: order_by
    id: order_by
    implements: order_by
    issuer_id: order_by
    iteration: order_by
    kalamint_edition: order_by
    kalamint_editions: order_by
    ledger_type: order_by
    level: order_by
    metadata_uri: order_by
    offer_id: order_by
    ophash: order_by
    opid: order_by
    owner_address: order_by
    price: order_by
    price_increment: order_by
    reserve: order_by
    rgb: order_by
    royalties: order_by
    seller_address: order_by
    start_price: order_by
    start_time: order_by
    swap_id: order_by
    timestamp: order_by
    to_address: order_by
    token_description: order_by
    token_id: order_by
    token_name: order_by
    total_price: order_by
    type: order_by
}

"order by min() on columns of table \"events\""
input events_min_order_by {
    amount: order_by
    artist_address: order_by
    ask_id: order_by
    auction_id: order_by
    bid: order_by
    bid_id: order_by
    bidder_address: order_by
    buyer_address: order_by
    collection_id: order_by
    creator_name: order_by
    currency: order_by
    current_price: order_by
    editions: order_by
    eightscribo_rowone: order_by
    eightscribo_rowthree: order_by
    eightscribo_rowtwo: order_by
    eightscribo_title: order_by
    end_price: order_by
    end_time: order_by
    extension_time: order_by
    fa2_address: order_by
    from_address: order_by
    highest_bidder_address: order_by
    holder_address: order_by
    id: order_by
    implements: order_by
    issuer_id: order_by
    iteration: order_by
    kalamint_edition: order_by
    kalamint_editions: order_by
    ledger_type: order_by
    level: order_by
    metadata_uri: order_by
    offer_id: order_by
    ophash: order_by
    opid: order_by
    owner_address: order_by
    price: order_by
    price_increment: order_by
    reserve: order_by
    rgb: order_by
    royalties: order_by
    seller_address: order_by
    start_price: order_by
    start_time: order_by
    swap_id: order_by
    timestamp: order_by
    to_address: order_by
    token_description: order_by
    token_id: order_by
    token_name: order_by
    total_price: order_by
    type: order_by
}

"Ordering options when selecting data from \"events\"."
input events_order_by {
    amount: order_by
    artist_address: order_by
    artist_profile: tzprofiles_order_by
    ask_id: order_by
    auction_id: order_by
    bid: order_by
    bid_id: order_by
    bidder_address: order_by
    bidder_profile: tzprofiles_order_by
    burn_on_end: order_by
    buyer_address: order_by
    buyer_profile: tzprofiles_order_by
    collection_id: order_by
    creator_name: order_by
    currency: order_by
    current_price: order_by
    editions: order_by
    eightscribo_rowone: order_by
    eightscribo_rowthree: order_by
    eightscribo_rowtwo: order_by
    eightscribo_title: order_by
    end_price: order_by
    end_time: order_by
    extension_time: order_by
    fa2_address: order_by
    from_address: order_by
    from_profile: tzprofiles_order_by
    highest_bidder_address: order_by
    highest_bidder_profile: tzprofiles_order_by
    holder_address: order_by
    holder_profile: tzprofiles_order_by
    id: order_by
    implements: order_by
    is_mint: order_by
    is_verified_artist: order_by
    issuer_id: order_by
    iteration: order_by
    kalamint_edition: order_by
    kalamint_editions: order_by
    ledger_type: order_by
    level: order_by
    metadata: order_by
    metadata_uri: order_by
    offer_id: order_by
    ophash: order_by
    opid: order_by
    owner_address: order_by
    owner_profile: tzprofiles_order_by
    price: order_by
    price_increment: order_by
    reserve: order_by
    rgb: order_by
    royalties: order_by
    royalty_shares: order_by
    seller_address: order_by
    seller_profile: tzprofiles_order_by
    start_price: order_by
    start_time: order_by
    swap_id: order_by
    timestamp: order_by
    to_address: order_by
    to_profile: tzprofiles_order_by
    token: tokens_order_by
    token_description: order_by
    token_id: order_by
    token_name: order_by
    total_price: order_by
    type: order_by
}

"order by stddev() on columns of table \"events\""
input events_stddev_order_by {
    amount: order_by
    ask_id: order_by
    auction_id: order_by
    bid: order_by
    bid_id: order_by
    collection_id: order_by
    current_price: order_by
    editions: order_by
    end_price: order_by
    extension_time: order_by
    issuer_id: order_by
    iteration: order_by
    kalamint_edition: order_by
    kalamint_editions: order_by
    level: order_by
    offer_id: order_by
    opid: order_by
    price: order_by
    price_increment: order_by
    reserve: order_by
    royalties: order_by
    start_price: order_by
    swap_id: order_by
    total_price: order_by
}

"order by stddev_pop() on columns of table \"events\""
input events_stddev_pop_order_by {
    amount: order_by
    ask_id: order_by
    auction_id: order_by
    bid: order_by
    bid_id: order_by
    collection_id: order_by
    current_price: order_by
    editions: order_by
    end_price: order_by
    extension_time: order_by
    issuer_id: order_by
    iteration: order_by
    kalamint_edition: order_by
    kalamint_editions: order_by
    level: order_by
    offer_id: order_by
    opid: order_by
    price: order_by
    price_increment: order_by
    reserve: order_by
    royalties: order_by
    start_price: order_by
    swap_id: order_by
    total_price: order_by
}

"order by stddev_samp() on columns of table \"events\""
input events_stddev_samp_order_by {
    amount: order_by
    ask_id: order_by
    auction_id: order_by
    bid: order_by
    bid_id: order_by
    collection_id: order_by
    current_price: order_by
    editions: order_by
    end_price: order_by
    extension_time: order_by
    issuer_id: order_by
    iteration: order_by
    kalamint_edition: order_by
    kalamint_editions: order_by
    level: order_by
    offer_id: order_by
    opid: order_by
    price: order_by
    price_increment: order_by
    reserve: order_by
    royalties: order_by
    start_price: order_by
    swap_id: order_by
    total_price: order_by
}

"order by sum() on columns of table \"events\""
input events_sum_order_by {
    amount: order_by
    ask_id: order_by
    auction_id: order_by
    bid: order_by
    bid_id: order_by
    collection_id: order_by
    current_price: order_by
    editions: order_by
    end_price: order_by
    extension_time: order_by
    issuer_id: order_by
    iteration: order_by
    kalamint_edition: order_by
    kalamint_editions: order_by
    level: order_by
    offer_id: order_by
    opid: order_by
    price: order_by
    price_increment: order_by
    reserve: order_by
    royalties: order_by
    start_price: order_by
    swap_id: order_by
    total_price: order_by
}

"order by var_pop() on columns of table \"events\""
input events_var_pop_order_by {
    amount: order_by
    ask_id: order_by
    auction_id: order_by
    bid: order_by
    bid_id: order_by
    collection_id: order_by
    current_price: order_by
    editions: order_by
    end_price: order_by
    extension_time: order_by
    issuer_id: order_by
    iteration: order_by
    kalamint_edition: order_by
    kalamint_editions: order_by
    level: order_by
    offer_id: order_by
    opid: order_by
    price: order_by
    price_increment: order_by
    reserve: order_by
    royalties: order_by
    start_price: order_by
    swap_id: order_by
    total_price: order_by
}

"order by var_samp() on columns of table \"events\""
input events_var_samp_order_by {
    amount: order_by
    ask_id: order_by
    auction_id: order_by
    bid: order_by
    bid_id: order_by
    collection_id: order_by
    current_price: order_by
    editions: order_by
    end_price: order_by
    extension_time: order_by
    issuer_id: order_by
    iteration: order_by
    kalamint_edition: order_by
    kalamint_editions: order_by
    level: order_by
    offer_id: order_by
    opid: order_by
    price: order_by
    price_increment: order_by
    reserve: order_by
    royalties: order_by
    start_price: order_by
    swap_id: order_by
    total_price: order_by
}

"order by variance() on columns of table \"events\""
input events_variance_order_by {
    amount: order_by
    ask_id: order_by
    auction_id: order_by
    bid: order_by
    bid_id: order_by
    collection_id: order_by
    current_price: order_by
    editions: order_by
    end_price: order_by
    extension_time: order_by
    issuer_id: order_by
    iteration: order_by
    kalamint_edition: order_by
    kalamint_editions: order_by
    level: order_by
    offer_id: order_by
    opid: order_by
    price: order_by
    price_increment: order_by
    reserve: order_by
    royalties: order_by
    start_price: order_by
    swap_id: order_by
    total_price: order_by
}

"order by aggregate values of table \"holdings\""
input holdings_aggregate_order_by {
    avg: holdings_avg_order_by
    count: order_by
    max: holdings_max_order_by
    min: holdings_min_order_by
    stddev: holdings_stddev_order_by
    stddev_pop: holdings_stddev_pop_order_by
    stddev_samp: holdings_stddev_samp_order_by
    sum: holdings_sum_order_by
    var_pop: holdings_var_pop_order_by
    var_samp: holdings_var_samp_order_by
    variance: holdings_variance_order_by
}

"order by avg() on columns of table \"holdings\""
input holdings_avg_order_by {
    amount: order_by
}

"Boolean expression to filter rows from the table \"holdings\". All fields are combined with a logical 'AND'."
input holdings_bool_exp {
    _and: [holdings_bool_exp!]
    _not: holdings_bool_exp
    _or: [holdings_bool_exp!]
    amount: bigint_comparison_exp
    fa2_address: String_comparison_exp
    first_received_at: timestamptz_comparison_exp
    holder_address: String_comparison_exp
    holder_profile: tzprofiles_bool_exp
    last_received_at: timestamptz_comparison_exp
    token: tokens_bool_exp
    token_id: String_comparison_exp
}

"order by max() on columns of table \"holdings\""
input holdings_max_order_by {
    amount: order_by
    fa2_address: order_by
    first_received_at: order_by
    holder_address: order_by
    last_received_at: order_by
    token_id: order_by
}

"order by min() on columns of table \"holdings\""
input holdings_min_order_by {
    amount: order_by
    fa2_address: order_by
    first_received_at: order_by
    holder_address: order_by
    last_received_at: order_by
    token_id: order_by
}

"Ordering options when selecting data from \"holdings\"."
input holdings_order_by {
    amount: order_by
    fa2_address: order_by
    first_received_at: order_by
    holder_address: order_by
    holder_profile: tzprofiles_order_by
    last_received_at: order_by
    token: tokens_order_by
    token_id: order_by
}

"order by stddev() on columns of table \"holdings\""
input holdings_stddev_order_by {
    amount: order_by
}

"order by stddev_pop() on columns of table \"holdings\""
input holdings_stddev_pop_order_by {
    amount: order_by
}

"order by stddev_samp() on columns of table \"holdings\""
input holdings_stddev_samp_order_by {
    amount: order_by
}

"order by sum() on columns of table \"holdings\""
input holdings_sum_order_by {
    amount: order_by
}

"order by var_pop() on columns of table \"holdings\""
input holdings_var_pop_order_by {
    amount: order_by
}

"order by var_samp() on columns of table \"holdings\""
input holdings_var_samp_order_by {
    amount: order_by
}

"order by variance() on columns of table \"holdings\""
input holdings_variance_order_by {
    amount: order_by
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
    "is the column contained in the given json value"
    _contained_in: jsonb
    "does the column contain the given json value at the top level"
    _contains: jsonb
    _eq: jsonb
    _gt: jsonb
    _gte: jsonb
    "does the string exist as a top-level key in the column"
    _has_key: String
    "do all of these strings exist as top-level keys in the column"
    _has_keys_all: [String!]
    "do any of these strings exist as top-level keys in the column"
    _has_keys_any: [String!]
    _in: [jsonb!]
    _is_null: Boolean
    _lt: jsonb
    _lte: jsonb
    _neq: jsonb
    _nin: [jsonb!]
}

"order by aggregate values of table \"listings\""
input listings_aggregate_order_by {
    avg: listings_avg_order_by
    count: order_by
    max: listings_max_order_by
    min: listings_min_order_by
    stddev: listings_stddev_order_by
    stddev_pop: listings_stddev_pop_order_by
    stddev_samp: listings_stddev_samp_order_by
    sum: listings_sum_order_by
    var_pop: listings_var_pop_order_by
    var_samp: listings_var_samp_order_by
    variance: listings_variance_order_by
}

"order by avg() on columns of table \"listings\""
input listings_avg_order_by {
    amount: order_by
    amount_left: order_by
    ask_id: order_by
    end_price: order_by
    offer_id: order_by
    price: order_by
    start_price: order_by
    swap_id: order_by
}

"Boolean expression to filter rows from the table \"listings\". All fields are combined with a logical 'AND'."
input listings_bool_exp {
    _and: [listings_bool_exp!]
    _not: listings_bool_exp
    _or: [listings_bool_exp!]
    amount: bigint_comparison_exp
    amount_left: bigint_comparison_exp
    ask_id: bigint_comparison_exp
    burn_on_end: Boolean_comparison_exp
    contract_address: String_comparison_exp
    created_at: timestamptz_comparison_exp
    currency: String_comparison_exp
    end_price: bigint_comparison_exp
    end_time: timestamptz_comparison_exp
    fa2_address: String_comparison_exp
    offer_id: bigint_comparison_exp
    price: bigint_comparison_exp
    seller_address: String_comparison_exp
    seller_profile: tzprofiles_bool_exp
    start_price: bigint_comparison_exp
    status: String_comparison_exp
    swap_id: bigint_comparison_exp
    token: tokens_bool_exp
    token_id: String_comparison_exp
    type: String_comparison_exp
}

"order by max() on columns of table \"listings\""
input listings_max_order_by {
    amount: order_by
    amount_left: order_by
    ask_id: order_by
    contract_address: order_by
    created_at: order_by
    currency: order_by
    end_price: order_by
    end_time: order_by
    fa2_address: order_by
    offer_id: order_by
    price: order_by
    seller_address: order_by
    start_price: order_by
    status: order_by
    swap_id: order_by
    token_id: order_by
    type: order_by
}

"order by min() on columns of table \"listings\""
input listings_min_order_by {
    amount: order_by
    amount_left: order_by
    ask_id: order_by
    contract_address: order_by
    created_at: order_by
    currency: order_by
    end_price: order_by
    end_time: order_by
    fa2_address: order_by
    offer_id: order_by
    price: order_by
    seller_address: order_by
    start_price: order_by
    status: order_by
    swap_id: order_by
    token_id: order_by
    type: order_by
}

"Ordering options when selecting data from \"listings\"."
input listings_order_by {
    amount: order_by
    amount_left: order_by
    ask_id: order_by
    burn_on_end: order_by
    contract_address: order_by
    created_at: order_by
    currency: order_by
    end_price: order_by
    end_time: order_by
    fa2_address: order_by
    offer_id: order_by
    price: order_by
    seller_address: order_by
    seller_profile: tzprofiles_order_by
    start_price: order_by
    status: order_by
    swap_id: order_by
    token: tokens_order_by
    token_id: order_by
    type: order_by
}

"order by stddev() on columns of table \"listings\""
input listings_stddev_order_by {
    amount: order_by
    amount_left: order_by
    ask_id: order_by
    end_price: order_by
    offer_id: order_by
    price: order_by
    start_price: order_by
    swap_id: order_by
}

"order by stddev_pop() on columns of table \"listings\""
input listings_stddev_pop_order_by {
    amount: order_by
    amount_left: order_by
    ask_id: order_by
    end_price: order_by
    offer_id: order_by
    price: order_by
    start_price: order_by
    swap_id: order_by
}

"order by stddev_samp() on columns of table \"listings\""
input listings_stddev_samp_order_by {
    amount: order_by
    amount_left: order_by
    ask_id: order_by
    end_price: order_by
    offer_id: order_by
    price: order_by
    start_price: order_by
    swap_id: order_by
}

"order by sum() on columns of table \"listings\""
input listings_sum_order_by {
    amount: order_by
    amount_left: order_by
    ask_id: order_by
    end_price: order_by
    offer_id: order_by
    price: order_by
    start_price: order_by
    swap_id: order_by
}

"order by var_pop() on columns of table \"listings\""
input listings_var_pop_order_by {
    amount: order_by
    amount_left: order_by
    ask_id: order_by
    end_price: order_by
    offer_id: order_by
    price: order_by
    start_price: order_by
    swap_id: order_by
}

"order by var_samp() on columns of table \"listings\""
input listings_var_samp_order_by {
    amount: order_by
    amount_left: order_by
    ask_id: order_by
    end_price: order_by
    offer_id: order_by
    price: order_by
    start_price: order_by
    swap_id: order_by
}

"order by variance() on columns of table \"listings\""
input listings_variance_order_by {
    amount: order_by
    amount_left: order_by
    ask_id: order_by
    end_price: order_by
    offer_id: order_by
    price: order_by
    start_price: order_by
    swap_id: order_by
}

"order by aggregate values of table \"offers\""
input offers_aggregate_order_by {
    avg: offers_avg_order_by
    count: order_by
    max: offers_max_order_by
    min: offers_min_order_by
    stddev: offers_stddev_order_by
    stddev_pop: offers_stddev_pop_order_by
    stddev_samp: offers_stddev_samp_order_by
    sum: offers_sum_order_by
    var_pop: offers_var_pop_order_by
    var_samp: offers_var_samp_order_by
    variance: offers_variance_order_by
}

"order by avg() on columns of table \"offers\""
input offers_avg_order_by {
    amount: order_by
    bid_id: order_by
    offer_id: order_by
    price: order_by
}

"Boolean expression to filter rows from the table \"offers\". All fields are combined with a logical 'AND'."
input offers_bool_exp {
    _and: [offers_bool_exp!]
    _not: offers_bool_exp
    _or: [offers_bool_exp!]
    amount: bigint_comparison_exp
    bid_id: bigint_comparison_exp
    buyer_address: String_comparison_exp
    buyer_profile: tzprofiles_bool_exp
    contract_address: String_comparison_exp
    created_at: timestamptz_comparison_exp
    currency: String_comparison_exp
    fa2_address: String_comparison_exp
    offer_id: bigint_comparison_exp
    price: bigint_comparison_exp
    status: String_comparison_exp
    token: tokens_bool_exp
    token_id: String_comparison_exp
    type: String_comparison_exp
}

"order by max() on columns of table \"offers\""
input offers_max_order_by {
    amount: order_by
    bid_id: order_by
    buyer_address: order_by
    contract_address: order_by
    created_at: order_by
    currency: order_by
    fa2_address: order_by
    offer_id: order_by
    price: order_by
    status: order_by
    token_id: order_by
    type: order_by
}

"order by min() on columns of table \"offers\""
input offers_min_order_by {
    amount: order_by
    bid_id: order_by
    buyer_address: order_by
    contract_address: order_by
    created_at: order_by
    currency: order_by
    fa2_address: order_by
    offer_id: order_by
    price: order_by
    status: order_by
    token_id: order_by
    type: order_by
}

"Ordering options when selecting data from \"offers\"."
input offers_order_by {
    amount: order_by
    bid_id: order_by
    buyer_address: order_by
    buyer_profile: tzprofiles_order_by
    contract_address: order_by
    created_at: order_by
    currency: order_by
    fa2_address: order_by
    offer_id: order_by
    price: order_by
    status: order_by
    token: tokens_order_by
    token_id: order_by
    type: order_by
}

"order by stddev() on columns of table \"offers\""
input offers_stddev_order_by {
    amount: order_by
    bid_id: order_by
    offer_id: order_by
    price: order_by
}

"order by stddev_pop() on columns of table \"offers\""
input offers_stddev_pop_order_by {
    amount: order_by
    bid_id: order_by
    offer_id: order_by
    price: order_by
}

"order by stddev_samp() on columns of table \"offers\""
input offers_stddev_samp_order_by {
    amount: order_by
    bid_id: order_by
    offer_id: order_by
    price: order_by
}

"order by sum() on columns of table \"offers\""
input offers_sum_order_by {
    amount: order_by
    bid_id: order_by
    offer_id: order_by
    price: order_by
}

"order by var_pop() on columns of table \"offers\""
input offers_var_pop_order_by {
    amount: order_by
    bid_id: order_by
    offer_id: order_by
    price: order_by
}

"order by var_samp() on columns of table \"offers\""
input offers_var_samp_order_by {
    amount: order_by
    bid_id: order_by
    offer_id: order_by
    price: order_by
}

"order by variance() on columns of table \"offers\""
input offers_variance_order_by {
    amount: order_by
    bid_id: order_by
    offer_id: order_by
    price: order_by
}

"order by aggregate values of table \"royalty_receivers\""
input royalty_receivers_aggregate_order_by {
    avg: royalty_receivers_avg_order_by
    count: order_by
    max: royalty_receivers_max_order_by
    min: royalty_receivers_min_order_by
    stddev: royalty_receivers_stddev_order_by
    stddev_pop: royalty_receivers_stddev_pop_order_by
    stddev_samp: royalty_receivers_stddev_samp_order_by
    sum: royalty_receivers_sum_order_by
    var_pop: royalty_receivers_var_pop_order_by
    var_samp: royalty_receivers_var_samp_order_by
    variance: royalty_receivers_variance_order_by
}

"order by avg() on columns of table \"royalty_receivers\""
input royalty_receivers_avg_order_by {
    royalties: order_by
}

"Boolean expression to filter rows from the table \"royalty_receivers\". All fields are combined with a logical 'AND'."
input royalty_receivers_bool_exp {
    _and: [royalty_receivers_bool_exp!]
    _not: royalty_receivers_bool_exp
    _or: [royalty_receivers_bool_exp!]
    fa2_address: String_comparison_exp
    receiver_address: String_comparison_exp
    receiver_profile: tzprofiles_bool_exp
    royalties: bigint_comparison_exp
    token: tokens_bool_exp
    token_id: String_comparison_exp
}

"order by max() on columns of table \"royalty_receivers\""
input royalty_receivers_max_order_by {
    fa2_address: order_by
    receiver_address: order_by
    royalties: order_by
    token_id: order_by
}

"order by min() on columns of table \"royalty_receivers\""
input royalty_receivers_min_order_by {
    fa2_address: order_by
    receiver_address: order_by
    royalties: order_by
    token_id: order_by
}

"Ordering options when selecting data from \"royalty_receivers\"."
input royalty_receivers_order_by {
    fa2_address: order_by
    receiver_address: order_by
    receiver_profile: tzprofiles_order_by
    royalties: order_by
    token: tokens_order_by
    token_id: order_by
}

"order by stddev() on columns of table \"royalty_receivers\""
input royalty_receivers_stddev_order_by {
    royalties: order_by
}

"order by stddev_pop() on columns of table \"royalty_receivers\""
input royalty_receivers_stddev_pop_order_by {
    royalties: order_by
}

"order by stddev_samp() on columns of table \"royalty_receivers\""
input royalty_receivers_stddev_samp_order_by {
    royalties: order_by
}

"order by sum() on columns of table \"royalty_receivers\""
input royalty_receivers_sum_order_by {
    royalties: order_by
}

"order by var_pop() on columns of table \"royalty_receivers\""
input royalty_receivers_var_pop_order_by {
    royalties: order_by
}

"order by var_samp() on columns of table \"royalty_receivers\""
input royalty_receivers_var_samp_order_by {
    royalties: order_by
}

"order by variance() on columns of table \"royalty_receivers\""
input royalty_receivers_variance_order_by {
    royalties: order_by
}

"order by aggregate values of table \"tags\""
input tags_aggregate_order_by {
    count: order_by
    max: tags_max_order_by
    min: tags_min_order_by
}

"Boolean expression to filter rows from the table \"tags\". All fields are combined with a logical 'AND'."
input tags_bool_exp {
    _and: [tags_bool_exp!]
    _not: tags_bool_exp
    _or: [tags_bool_exp!]
    fa2_address: String_comparison_exp
    tag: String_comparison_exp
    token: tokens_bool_exp
    token_id: String_comparison_exp
}

"order by max() on columns of table \"tags\""
input tags_max_order_by {
    fa2_address: order_by
    tag: order_by
    token_id: order_by
}

"order by min() on columns of table \"tags\""
input tags_min_order_by {
    fa2_address: order_by
    tag: order_by
    token_id: order_by
}

"Ordering options when selecting data from \"tags\"."
input tags_order_by {
    fa2_address: order_by
    tag: order_by
    token: tokens_order_by
    token_id: order_by
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
}

"Boolean expression to filter rows from the table \"token_metadata\". All fields are combined with a logical 'AND'."
input token_metadata_bool_exp {
    _and: [token_metadata_bool_exp!]
    _not: token_metadata_bool_exp
    _or: [token_metadata_bool_exp!]
    data: jsonb_comparison_exp
    status: String_comparison_exp
    tokens: tokens_bool_exp
    uri: String_comparison_exp
}

"Ordering options when selecting data from \"token_metadata\"."
input token_metadata_order_by {
    data: order_by
    status: order_by
    tokens_aggregate: tokens_aggregate_order_by
    uri: order_by
}

"order by aggregate values of table \"tokens\""
input tokens_aggregate_order_by {
    avg: tokens_avg_order_by
    count: order_by
    max: tokens_max_order_by
    min: tokens_min_order_by
    stddev: tokens_stddev_order_by
    stddev_pop: tokens_stddev_pop_order_by
    stddev_samp: tokens_stddev_samp_order_by
    sum: tokens_sum_order_by
    var_pop: tokens_var_pop_order_by
    var_samp: tokens_var_samp_order_by
    variance: tokens_variance_order_by
}

"order by avg() on columns of table \"tokens\""
input tokens_avg_order_by {
    burned_editions: order_by
    current_price_to_first_sales_price_diff: order_by
    current_price_to_first_sales_price_pct: order_by
    current_price_to_highest_sales_price_diff: order_by
    current_price_to_highest_sales_price_pct: order_by
    current_price_to_last_sales_price_diff: order_by
    current_price_to_last_sales_price_pct: order_by
    current_price_to_lowest_sales_price_diff: order_by
    current_price_to_lowest_sales_price_pct: order_by
    editions: order_by
    first_sales_price: order_by
    fx_collection_editions: order_by
    fx_issuer_id: order_by
    fx_iteration: order_by
    highest_offer_price: order_by
    highest_sales_price: order_by
    last_processed_event_level: order_by
    last_sales_price: order_by
    lowest_sales_price: order_by
    mint_price: order_by
    objkt_artist_collection_id: order_by
    price: order_by
    royalties_total: order_by
    sales_count: order_by
    sales_volume: order_by
}

"Boolean expression to filter rows from the table \"tokens\". All fields are combined with a logical 'AND'."
input tokens_bool_exp {
    _and: [tokens_bool_exp!]
    _not: tokens_bool_exp
    _or: [tokens_bool_exp!]
    artifact_metadata: jsonb_comparison_exp
    artifact_uri: String_comparison_exp
    artist_address: String_comparison_exp
    artist_profile: tzprofiles_bool_exp
    assets: jsonb_comparison_exp
    attributes: jsonb_comparison_exp
    burned_editions: bigint_comparison_exp
    contributors: jsonb_comparison_exp
    creators: jsonb_comparison_exp
    current_price_to_first_sales_price_diff: bigint_comparison_exp
    current_price_to_first_sales_price_pct: bigint_comparison_exp
    current_price_to_highest_sales_price_diff: bigint_comparison_exp
    current_price_to_highest_sales_price_pct: bigint_comparison_exp
    current_price_to_last_sales_price_diff: bigint_comparison_exp
    current_price_to_last_sales_price_pct: bigint_comparison_exp
    current_price_to_lowest_sales_price_diff: bigint_comparison_exp
    current_price_to_lowest_sales_price_pct: bigint_comparison_exp
    description: String_comparison_exp
    display_uri: String_comparison_exp
    editions: bigint_comparison_exp
    eightbid_creator_name: String_comparison_exp
    eightbid_rgb: String_comparison_exp
    eightscribo_rowone: String_comparison_exp
    eightscribo_rowthree: String_comparison_exp
    eightscribo_rowtwo: String_comparison_exp
    eightscribo_title: String_comparison_exp
    events: events_bool_exp
    external_uri: String_comparison_exp
    fa2_address: String_comparison_exp
    first_sales_price: bigint_comparison_exp
    formats: jsonb_comparison_exp
    fx_collection_description: String_comparison_exp
    fx_collection_display_uri: String_comparison_exp
    fx_collection_editions: bigint_comparison_exp
    fx_collection_name: String_comparison_exp
    fx_collection_thumbnail_uri: String_comparison_exp
    fx_issuer_id: bigint_comparison_exp
    fx_iteration: bigint_comparison_exp
    highest_offer_price: bigint_comparison_exp
    highest_sales_price: bigint_comparison_exp
    holdings: holdings_bool_exp
    is_verified_artist: Boolean_comparison_exp
    last_processed_event_id: String_comparison_exp
    last_processed_event_level: bigint_comparison_exp
    last_processed_event_timestamp: timestamptz_comparison_exp
    last_sale_at: timestamptz_comparison_exp
    last_sales_price: bigint_comparison_exp
    listings: listings_bool_exp
    lowest_price_listing: jsonb_comparison_exp
    lowest_sales_price: bigint_comparison_exp
    metadata: token_metadata_bool_exp
    metadata_status: String_comparison_exp
    metadata_uri: String_comparison_exp
    mime_type: String_comparison_exp
    mint_price: bigint_comparison_exp
    minted_at: timestamptz_comparison_exp
    minter_address: String_comparison_exp
    minter_profile: tzprofiles_bool_exp
    name: String_comparison_exp
    objkt_artist_collection_id: bigint_comparison_exp
    offers: offers_bool_exp
    platform: String_comparison_exp
    price: bigint_comparison_exp
    right_uri: String_comparison_exp
    rights: String_comparison_exp
    royalties: jsonb_comparison_exp
    royalties_total: bigint_comparison_exp
    royalty_receivers: royalty_receivers_bool_exp
    sales_count: bigint_comparison_exp
    sales_volume: bigint_comparison_exp
    symbol: String_comparison_exp
    tags: tags_bool_exp
    thumbnail_uri: String_comparison_exp
    token_id: String_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"tokens\""
input tokens_max_order_by {
    artifact_uri: order_by
    artist_address: order_by
    burned_editions: order_by
    current_price_to_first_sales_price_diff: order_by
    current_price_to_first_sales_price_pct: order_by
    current_price_to_highest_sales_price_diff: order_by
    current_price_to_highest_sales_price_pct: order_by
    current_price_to_last_sales_price_diff: order_by
    current_price_to_last_sales_price_pct: order_by
    current_price_to_lowest_sales_price_diff: order_by
    current_price_to_lowest_sales_price_pct: order_by
    description: order_by
    display_uri: order_by
    editions: order_by
    eightbid_creator_name: order_by
    eightbid_rgb: order_by
    eightscribo_rowone: order_by
    eightscribo_rowthree: order_by
    eightscribo_rowtwo: order_by
    eightscribo_title: order_by
    external_uri: order_by
    fa2_address: order_by
    first_sales_price: order_by
    fx_collection_description: order_by
    fx_collection_display_uri: order_by
    fx_collection_editions: order_by
    fx_collection_name: order_by
    fx_collection_thumbnail_uri: order_by
    fx_issuer_id: order_by
    fx_iteration: order_by
    highest_offer_price: order_by
    highest_sales_price: order_by
    last_processed_event_id: order_by
    last_processed_event_level: order_by
    last_processed_event_timestamp: order_by
    last_sale_at: order_by
    last_sales_price: order_by
    lowest_sales_price: order_by
    metadata_status: order_by
    metadata_uri: order_by
    mime_type: order_by
    mint_price: order_by
    minted_at: order_by
    minter_address: order_by
    name: order_by
    objkt_artist_collection_id: order_by
    platform: order_by
    price: order_by
    right_uri: order_by
    rights: order_by
    royalties_total: order_by
    sales_count: order_by
    sales_volume: order_by
    symbol: order_by
    thumbnail_uri: order_by
    token_id: order_by
    updated_at: order_by
}

"order by min() on columns of table \"tokens\""
input tokens_min_order_by {
    artifact_uri: order_by
    artist_address: order_by
    burned_editions: order_by
    current_price_to_first_sales_price_diff: order_by
    current_price_to_first_sales_price_pct: order_by
    current_price_to_highest_sales_price_diff: order_by
    current_price_to_highest_sales_price_pct: order_by
    current_price_to_last_sales_price_diff: order_by
    current_price_to_last_sales_price_pct: order_by
    current_price_to_lowest_sales_price_diff: order_by
    current_price_to_lowest_sales_price_pct: order_by
    description: order_by
    display_uri: order_by
    editions: order_by
    eightbid_creator_name: order_by
    eightbid_rgb: order_by
    eightscribo_rowone: order_by
    eightscribo_rowthree: order_by
    eightscribo_rowtwo: order_by
    eightscribo_title: order_by
    external_uri: order_by
    fa2_address: order_by
    first_sales_price: order_by
    fx_collection_description: order_by
    fx_collection_display_uri: order_by
    fx_collection_editions: order_by
    fx_collection_name: order_by
    fx_collection_thumbnail_uri: order_by
    fx_issuer_id: order_by
    fx_iteration: order_by
    highest_offer_price: order_by
    highest_sales_price: order_by
    last_processed_event_id: order_by
    last_processed_event_level: order_by
    last_processed_event_timestamp: order_by
    last_sale_at: order_by
    last_sales_price: order_by
    lowest_sales_price: order_by
    metadata_status: order_by
    metadata_uri: order_by
    mime_type: order_by
    mint_price: order_by
    minted_at: order_by
    minter_address: order_by
    name: order_by
    objkt_artist_collection_id: order_by
    platform: order_by
    price: order_by
    right_uri: order_by
    rights: order_by
    royalties_total: order_by
    sales_count: order_by
    sales_volume: order_by
    symbol: order_by
    thumbnail_uri: order_by
    token_id: order_by
    updated_at: order_by
}

"Ordering options when selecting data from \"tokens\"."
input tokens_order_by {
    artifact_metadata: order_by
    artifact_uri: order_by
    artist_address: order_by
    artist_profile: tzprofiles_order_by
    assets: order_by
    attributes: order_by
    burned_editions: order_by
    contributors: order_by
    creators: order_by
    current_price_to_first_sales_price_diff: order_by
    current_price_to_first_sales_price_pct: order_by
    current_price_to_highest_sales_price_diff: order_by
    current_price_to_highest_sales_price_pct: order_by
    current_price_to_last_sales_price_diff: order_by
    current_price_to_last_sales_price_pct: order_by
    current_price_to_lowest_sales_price_diff: order_by
    current_price_to_lowest_sales_price_pct: order_by
    description: order_by
    display_uri: order_by
    editions: order_by
    eightbid_creator_name: order_by
    eightbid_rgb: order_by
    eightscribo_rowone: order_by
    eightscribo_rowthree: order_by
    eightscribo_rowtwo: order_by
    eightscribo_title: order_by
    events_aggregate: events_aggregate_order_by
    external_uri: order_by
    fa2_address: order_by
    first_sales_price: order_by
    formats: order_by
    fx_collection_description: order_by
    fx_collection_display_uri: order_by
    fx_collection_editions: order_by
    fx_collection_name: order_by
    fx_collection_thumbnail_uri: order_by
    fx_issuer_id: order_by
    fx_iteration: order_by
    highest_offer_price: order_by
    highest_sales_price: order_by
    holdings_aggregate: holdings_aggregate_order_by
    is_verified_artist: order_by
    last_processed_event_id: order_by
    last_processed_event_level: order_by
    last_processed_event_timestamp: order_by
    last_sale_at: order_by
    last_sales_price: order_by
    listings_aggregate: listings_aggregate_order_by
    lowest_price_listing: order_by
    lowest_sales_price: order_by
    metadata: token_metadata_order_by
    metadata_status: order_by
    metadata_uri: order_by
    mime_type: order_by
    mint_price: order_by
    minted_at: order_by
    minter_address: order_by
    minter_profile: tzprofiles_order_by
    name: order_by
    objkt_artist_collection_id: order_by
    offers_aggregate: offers_aggregate_order_by
    platform: order_by
    price: order_by
    right_uri: order_by
    rights: order_by
    royalties: order_by
    royalties_total: order_by
    royalty_receivers_aggregate: royalty_receivers_aggregate_order_by
    sales_count: order_by
    sales_volume: order_by
    symbol: order_by
    tags_aggregate: tags_aggregate_order_by
    thumbnail_uri: order_by
    token_id: order_by
    updated_at: order_by
}

"order by stddev() on columns of table \"tokens\""
input tokens_stddev_order_by {
    burned_editions: order_by
    current_price_to_first_sales_price_diff: order_by
    current_price_to_first_sales_price_pct: order_by
    current_price_to_highest_sales_price_diff: order_by
    current_price_to_highest_sales_price_pct: order_by
    current_price_to_last_sales_price_diff: order_by
    current_price_to_last_sales_price_pct: order_by
    current_price_to_lowest_sales_price_diff: order_by
    current_price_to_lowest_sales_price_pct: order_by
    editions: order_by
    first_sales_price: order_by
    fx_collection_editions: order_by
    fx_issuer_id: order_by
    fx_iteration: order_by
    highest_offer_price: order_by
    highest_sales_price: order_by
    last_processed_event_level: order_by
    last_sales_price: order_by
    lowest_sales_price: order_by
    mint_price: order_by
    objkt_artist_collection_id: order_by
    price: order_by
    royalties_total: order_by
    sales_count: order_by
    sales_volume: order_by
}

"order by stddev_pop() on columns of table \"tokens\""
input tokens_stddev_pop_order_by {
    burned_editions: order_by
    current_price_to_first_sales_price_diff: order_by
    current_price_to_first_sales_price_pct: order_by
    current_price_to_highest_sales_price_diff: order_by
    current_price_to_highest_sales_price_pct: order_by
    current_price_to_last_sales_price_diff: order_by
    current_price_to_last_sales_price_pct: order_by
    current_price_to_lowest_sales_price_diff: order_by
    current_price_to_lowest_sales_price_pct: order_by
    editions: order_by
    first_sales_price: order_by
    fx_collection_editions: order_by
    fx_issuer_id: order_by
    fx_iteration: order_by
    highest_offer_price: order_by
    highest_sales_price: order_by
    last_processed_event_level: order_by
    last_sales_price: order_by
    lowest_sales_price: order_by
    mint_price: order_by
    objkt_artist_collection_id: order_by
    price: order_by
    royalties_total: order_by
    sales_count: order_by
    sales_volume: order_by
}

"order by stddev_samp() on columns of table \"tokens\""
input tokens_stddev_samp_order_by {
    burned_editions: order_by
    current_price_to_first_sales_price_diff: order_by
    current_price_to_first_sales_price_pct: order_by
    current_price_to_highest_sales_price_diff: order_by
    current_price_to_highest_sales_price_pct: order_by
    current_price_to_last_sales_price_diff: order_by
    current_price_to_last_sales_price_pct: order_by
    current_price_to_lowest_sales_price_diff: order_by
    current_price_to_lowest_sales_price_pct: order_by
    editions: order_by
    first_sales_price: order_by
    fx_collection_editions: order_by
    fx_issuer_id: order_by
    fx_iteration: order_by
    highest_offer_price: order_by
    highest_sales_price: order_by
    last_processed_event_level: order_by
    last_sales_price: order_by
    lowest_sales_price: order_by
    mint_price: order_by
    objkt_artist_collection_id: order_by
    price: order_by
    royalties_total: order_by
    sales_count: order_by
    sales_volume: order_by
}

"order by sum() on columns of table \"tokens\""
input tokens_sum_order_by {
    burned_editions: order_by
    current_price_to_first_sales_price_diff: order_by
    current_price_to_first_sales_price_pct: order_by
    current_price_to_highest_sales_price_diff: order_by
    current_price_to_highest_sales_price_pct: order_by
    current_price_to_last_sales_price_diff: order_by
    current_price_to_last_sales_price_pct: order_by
    current_price_to_lowest_sales_price_diff: order_by
    current_price_to_lowest_sales_price_pct: order_by
    editions: order_by
    first_sales_price: order_by
    fx_collection_editions: order_by
    fx_issuer_id: order_by
    fx_iteration: order_by
    highest_offer_price: order_by
    highest_sales_price: order_by
    last_processed_event_level: order_by
    last_sales_price: order_by
    lowest_sales_price: order_by
    mint_price: order_by
    objkt_artist_collection_id: order_by
    price: order_by
    royalties_total: order_by
    sales_count: order_by
    sales_volume: order_by
}

"order by var_pop() on columns of table \"tokens\""
input tokens_var_pop_order_by {
    burned_editions: order_by
    current_price_to_first_sales_price_diff: order_by
    current_price_to_first_sales_price_pct: order_by
    current_price_to_highest_sales_price_diff: order_by
    current_price_to_highest_sales_price_pct: order_by
    current_price_to_last_sales_price_diff: order_by
    current_price_to_last_sales_price_pct: order_by
    current_price_to_lowest_sales_price_diff: order_by
    current_price_to_lowest_sales_price_pct: order_by
    editions: order_by
    first_sales_price: order_by
    fx_collection_editions: order_by
    fx_issuer_id: order_by
    fx_iteration: order_by
    highest_offer_price: order_by
    highest_sales_price: order_by
    last_processed_event_level: order_by
    last_sales_price: order_by
    lowest_sales_price: order_by
    mint_price: order_by
    objkt_artist_collection_id: order_by
    price: order_by
    royalties_total: order_by
    sales_count: order_by
    sales_volume: order_by
}

"order by var_samp() on columns of table \"tokens\""
input tokens_var_samp_order_by {
    burned_editions: order_by
    current_price_to_first_sales_price_diff: order_by
    current_price_to_first_sales_price_pct: order_by
    current_price_to_highest_sales_price_diff: order_by
    current_price_to_highest_sales_price_pct: order_by
    current_price_to_last_sales_price_diff: order_by
    current_price_to_last_sales_price_pct: order_by
    current_price_to_lowest_sales_price_diff: order_by
    current_price_to_lowest_sales_price_pct: order_by
    editions: order_by
    first_sales_price: order_by
    fx_collection_editions: order_by
    fx_issuer_id: order_by
    fx_iteration: order_by
    highest_offer_price: order_by
    highest_sales_price: order_by
    last_processed_event_level: order_by
    last_sales_price: order_by
    lowest_sales_price: order_by
    mint_price: order_by
    objkt_artist_collection_id: order_by
    price: order_by
    royalties_total: order_by
    sales_count: order_by
    sales_volume: order_by
}

"order by variance() on columns of table \"tokens\""
input tokens_variance_order_by {
    burned_editions: order_by
    current_price_to_first_sales_price_diff: order_by
    current_price_to_first_sales_price_pct: order_by
    current_price_to_highest_sales_price_diff: order_by
    current_price_to_highest_sales_price_pct: order_by
    current_price_to_last_sales_price_diff: order_by
    current_price_to_last_sales_price_pct: order_by
    current_price_to_lowest_sales_price_diff: order_by
    current_price_to_lowest_sales_price_pct: order_by
    editions: order_by
    first_sales_price: order_by
    fx_collection_editions: order_by
    fx_issuer_id: order_by
    fx_iteration: order_by
    highest_offer_price: order_by
    highest_sales_price: order_by
    last_processed_event_level: order_by
    last_sales_price: order_by
    lowest_sales_price: order_by
    mint_price: order_by
    objkt_artist_collection_id: order_by
    price: order_by
    royalties_total: order_by
    sales_count: order_by
    sales_volume: order_by
}

"Boolean expression to filter rows from the table \"tzprofiles.tzprofiles\". All fields are combined with a logical 'AND'."
input tzprofiles_bool_exp {
    _and: [tzprofiles_bool_exp!]
    _not: tzprofiles_bool_exp
    _or: [tzprofiles_bool_exp!]
    account: String_comparison_exp
    alias: String_comparison_exp
    contract: String_comparison_exp
    description: String_comparison_exp
    discord: String_comparison_exp
    domain_name: String_comparison_exp
    ethereum: String_comparison_exp
    github: String_comparison_exp
    logo: String_comparison_exp
    twitter: String_comparison_exp
    website: String_comparison_exp
}

"Ordering options when selecting data from \"tzprofiles.tzprofiles\"."
input tzprofiles_order_by {
    account: order_by
    alias: order_by
    contract: order_by
    description: order_by
    discord: order_by
    domain_name: order_by
    ethereum: order_by
    github: order_by
    logo: order_by
    twitter: order_by
    website: order_by
}
